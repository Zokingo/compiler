//剩余可用结点名字:k,m,n,p,s,v,w

1、	文法开始：
S->void main(){A}//待修改(语法有错)|int main(){A return 0;}
----------------
S->Y  id(X){A}//待增加的子函数功能


2、	声明：
X-> YZ;
Y-> int|char|bool|float//bool声明待测试

Z-> UZ’
Z’-> ,Z|$ 
U-> idU’
U’-> =L|P|$//待测试的P赋值操作
----------------------------------
2(1)、自定义数据类型struct声明：i,j,
I->struct id{X};//待测试，语法分析时语义动作不完整
2(2)、数组的声明：
J->Y id[num];//待测试，没有语法分析
----------------------------------


3、	赋值：//待修改增加功能的测试补充
R->id=L;
---------------------------------
R->id=R'
R'->L|P;//这样赋值操作就可以覆盖表达式赋值以及常量或者变量的赋值操作了



4、	算术运算：
L->TL’
L’->+L|-L|$
T->FT’
T’->*T|/T|$
F->(L)

F->id|num

O->++|--|$
Q->idO|$

5、	布尔运算
E->HE’
E’->&&E|$
H->GH’
H’->||H
H’->$
G->FDF
G->(E)
G->!E
D-> <|>|==|!=
D-> <=|>=//新值逻辑算术符待测试

5、控制语句
B->if (E){A}else{A}//if语义动作不完整待修改
B->while(E){A}//while语义动作不完整待修改
B->for(YZ;G;Q){A}

6、功能函数
B->printf(P);
B->scanf(id);
P->id|ch|num|floatum|boolid//常量待测试

7、复合语句
A->CA
C->X|B|R|I(结构体定义)
A->$






1、构造LL1属性翻译文法
构造LL1属性翻译文法即在原有LL1文法基础上加上动作符号，并给非终结符和终结符加上一定属性，给动作符号加上语义子程序。
对原有LL1文法改进的地方如下：
1、	赋值：
产生式			语义子程序
R->@ASS_R id =L @EQ;

@ASS_R{R.VAL=id并压入语义栈}
@EQ{RES=R.VAL,OP=’=’,ARG1=L.VAL,new fourElement(OP,ARG1,_, RES)}

U->@ASS_U id U’ 		@ASS_U{U.VAL=id并压入语义栈}
U’->=L|$ @EQ_U’ 	    @EQ_U’{RES=U.VAL,OP=’=’,ARG1=L.VAL,new fourElement(OP,ARG1,_, RES)}

2、	算术运算：
产生式			语义子程序

L->TL’@ADD_SUB	 		@ADD_SUB{If(OP!=null) RES= NEWTEMP; L.VAL=RES,并压入语义栈;New fourElement(OP, T.VAL;,L’VAL, RES)，}
L’->+L@ADD				@ADD{OP=+,ARG2=L.VAL}
L’->-L@SUB				@SUB{OP=-,ARG2=L.VAL}
L’->$		
T->FT’@DIV_MUL			@DIV_MUL{ if (OP !=null) RES= NEWTEMP;T.VAL=RES; new FourElement(OP,F.VAL,ARG2, RES)else ARG1=F.VAL; }
T’->/T@DIV				@DIV{OP=/,ARG2=T.VAL}
T’->*T@MUL	 			@MUL{OP=*,ARG2=T.VAL}
T’->$
F->(L)@VOL				@VOL{F.VAL->L.VAL}

F->@ASS_F num|id		@ASS_F{F.VAL=num|id}
---------------------------------------------
F->@ASS_F num|id|floatnum		@ASS_F{F.VAL=num|id|floatnum}

Q->idO|$
O->@SINGLE_OP++|--		@SINGLE_OP{OP=++|--}

3、	布尔运算
产生式			语义子程序

G->FDF@COMPARE			@COMPARE{OP=D.VAL;ARG1=F(1).VAL;ARG2=F(2).VAL,RES=NEWTEMP; New fourElement(OP,F.VAL,ARG2, RES );G.VAL=RES并压入语义栈}
D->@COMPARE_OP<|>|==|!=	@COMPARE_OP{D.VAL=<|>|==|!=,并压入语栈}

4、	控制语句
产生式			语义子程序
B->if (G)@IF_FJ{A}@IF_BACKPATCH_FJ @IF_RJ else{A}@IF_BACKPATCH_RJ

@IF_FJ{OP=”FJ”;ARG1=G.VAL;RES=if_fj, New fourElement(OP,ARG1,_, RES ),将其插入到四元式列表中第i个}
@IF_BACKPATCH_FJ{回填前面假出口跳转四元式的跳转序号, BACKPATCH (i,if_fj)}

B->while(G)@WHILE_FJ{A}@WHILE_RJ@WHILE_BACKPATCH_FJ		{参照if else}

B->for(YZ;G@FOR_FJ;Q){A@SINGLE}@FOR_RJ@FOR_BACKPATCH_FJ			{参照if else }

@SINGLE	{ARG1=id;RES=NEWTEMP;New fourElement(OP,ARG1,_,RES)}



说明：
(1):R.VAL表示符号R的值，VAL是R的一个属性，其它类似。
(2):NEWTEMP()函数：每调用一次生成一个临时变量，依次为T1,T2,…,Tn。
(3):BACKPATCH (int i,int res):回填函数，用res回填第i个四元式的跳转地址。
(4):new fourElement(String OP,String ARG1,String ARG2,String RES):生成一个四元式(OP,ARG1,ARG2,RES)

